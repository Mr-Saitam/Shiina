```
Este package es una actualizacion de mi antiguo package llamado mega-dtbs (https://www.npmjs.com/package/mega-dtbs)
megadb es un manejador de archivos JSON, contiene multiples metodos las cuales te facilitiaran las cosas y podras trabajar de una forma sencilla, persistente y eficaz.

```
## Mejoras
```
- Ahora podras especificar el directorio donde se guardaran tus base de datos, tambien podras usar sub directorios.
- Se creo una db en memoria (ver el constructor de memoDB)
- Se agrego nuevos metodos y parametros especiales.
- Se actualizo absolutamente todo el codigo para una mejor legibilidad y funcionamiento.
- La base de datos ahora es mas persistente.
- Errores descriptivos.
```

## Importante

- Por default se creará una carpeta llamada **mega_databases** en la carpeta principal de tu proyecto **(puedes cambiar el nombre de esta carpeta en el constructor)** [crearDB](#crearDB). No borres dicha carpeta a menos que quieras borrar absolutamente todas tus base de datos.


## Changelog

v3.4.0
* Se mejoró la descripcion de los errores.
* Se agregó la posibilidad de actualizar la base de datos(con los nuevos datos) cada cierto tiempo para evitar que los archivos JSON se lleguen a reescribir rapidamente, mas informacion: [crearDB](#crearDB)

v3.3.0
* La mayoria de cosas(codigos) fueron reescritas.
* Se agrego 2 nuevos metodos (findKey, partition).
* El metodo obtener(alias get) ahora retornara undefined cuando no se logre obtener nada.
* El metodo filter retornara un objeto vacio {} en lugar de undefined.
* El metodo map retornara un array vacio [] en lugar de undefined.
* El metodo some ahora retornara unicamente true o false.

v3.0.0
* Se agrego 2 nuevos metodos (setIndex, delIndex).
* Ahora puedes especificar la carpeta donde se guardaran tus base de datos, mas informacion: [crearDB](#crearDB)

v2.8.0
* Se agrego el metodo some.
* Se agrego un alias en los metodos: establecer (set), obtener (get), tiene (has), eliminar (delete), sumar (add), restar (subtract), ordenar (sort) 
* Se creo el constructor memoDB la cual hará que puedas hacer una db en memoria, ver el apartado de [memoDB](#memoDB) para mas informacion.

v2.7.0
* Se mejoró el metodo sumar y restar, ahora se podrá ingresar numeros en formato string, tambien se mejoró la descripcion de los errores.

V2.6.0
* Se removio la comparacion de objetos ya que esto se puede hacer fuera del codigo.

V2.5.0
* Se añadio un identificador interno para cada base de datos, esto hara que se puedan diferenciar en caso de que tengas una db con el mismo nombre en diferentes sub directorios.

V2.4.0
* Se agrego 3 nuevos metodos (find, map, filter)

V1.9.0
* Se agrego 3 nuevos metodos (size, keys, values)

V1.7.0
* Se agregó el metodo purgeall.

V1.5.0
* Se arregló el readme.

V1.4.0
* Se arregló un bug en la funcion obtener.


## Constructor:
* [crearDB](#crearDB)
* [memoDB](#memoDB)

## Metodos:
* [establecer](#establecer)
* [size](#size)
* [obtener](#obtener)
* [tiene](#tiene)
* [eliminar](#eliminar)
* [datos](#datos)
* [push](#push)
* [extract](#extract)
* [sumar](#sumar)
* [restar](#restar)
* [keys](#keys)
* [values](#values)
* [purgeall](#purgeall)
* [ordenar](#ordenar)
* [random](#random)
* [existeDB](#existeDB)
* [find](#find)
* [filter](#filter)
* [map](#map)
* [some](#some)
* [setIndex](#setIndex)
* [delIndex](#delIndex)
* [findKey](#findKey)
* [partition](#partition)
* [convert_megadtbs](#convert_megadtbs)



## Instalacion:

```shell
npm install megadb --save
```


## Ejemplo del requerimiento del package:

```js
const db = require('megadb');
```


<a name="crearDB" />
### crearDB

```js
crearDB(nombre_db, sub_directorio)
```

Este constructor te permite crear una base de datos.


__Modo de uso__

Este constructor tiene **dos** modos de uso:

_Modo #1_

Este modo es el que siempre se ha usado, aqui debes de especificar el nombre de la base de datos y el sub directorio(opcional).

En este modo por default la carpeta donde se almacenarán tus bases de datos será **mega_databases**, y si esta carpeta no existe se creará automaticamente.

1. **nombre_db**: Nombre del archivo con el que se creara la base de datos, si el nombre de la base de datos que pusiste ya existia, lo que hara es devolver los datos existentes de esa db.
2. **sub_directorio** (opcional): Este argumento es opcional, es para especificar si quieres que la base de datos se guarde en un sub diréctorio dentro de la carpeta mega_databases.

__Ejemplo__

```js

//Ejemplo 1
const db = require('megadb');
let niveles = new db.crearDB('niveles');
/*
Esto hará que se cree la base de datos niveles.json dentro de la carpeta mega_databases

Estructura:

[–] node_modules
[+] mega_databases
    - niveles.json

*/

//Ejemplo 2
const db = require('megadb');
let economia = new db.crearDB('guild_1', 'economia_db');
/*
Esto hará que se cree un sub directorio llamado "economia_db" dentro de la carpeta mega_databases, y dentro de este sub directorio se creará la base de datos guild_1.json

Estructura:

[–] node_modules
[+] mega_databases
    [+] economia_db
        - guild_1.json
    - niveles.json
*/
```

_Modo #2_

Este modo te permite hacer lo mismo que el modo #1, la unica diferencia es que ahora puedes especificar el nombre de la carpeta donde se almacenaran tus bases de datos y tambien añadir la opcion de que tu base de datos no se llegue a reescribir rapidamente.

En este modo solo se puede hacer uso de un parametro la cual debe de contener un objeto con 3 propiedades:


1. **nombre**: Nombre del archivo con el que se creara la base de datos, si el nombre de la base de datos que pusiste ya existia, lo que hara es devolver los datos existentes de esa db, este parametro es obligatorio.
2. **carpeta** (opcional): Aqui deberas de colocar el nombre de la carpeta donde se guardaran tus bases de datos, si no colocas esta propiedad, por default será **mega_databases**.
3. **sub** (opcional): Esto tambien es opcional, aqui puedes especificar si quieres que la base de datos se guarde en un sub diréctorio dentro de la carpeta que especificaste en la propiedad **carpeta**.
4. **guardar_tiempo** (opcional): Aqui  deberas de colocar el tiempo (en segundos) que se deberá esperar para actualizar los datos en la base de datos, debe ser mayor a 4 segundos (usalo con precaucion).

__Ejemplo__

```js

//Ejemplo 1
const db = require('megadb');
let niveles = new db.crearDB({
  nombre: "levels",
  carpeta: "datos_niveles"
});
/*
Esto hará que se cree la base de datos levels.json dentro de la carpeta datos_niveles

Estructura:

[–] node_modules
[+] datos_niveles
    - levels.json

*/


//Ejemplo 2
const db = require('megadb');
let economia = new db.crearDB({
  nombre: 'usuarios',
  carpeta: "economia_db",
  sub: "dinero",
  guardar_tiempo: 5
});
/*
Esto hará que se cree un sub directorio llamado "dinero" dentro de la carpeta economia_db, y dentro de este sub directorio se creará la base de datos usuarios.json

Estructura:

[–] node_modules
[+] datos_niveles
    - levels.json
[+] economia_db
    [+] dinero
        - usuarios.json
*/
```

__Recuerda__

Cada base de datos tiene un indentificador interno, esto hará que se puedan diferenciar en caso de que uses una db con el mismo nombre en diferentes carpetas (ya sean sub directorios o la carpeta principal donde se guardan tus bases de datos).

Ten en cuenta que si usas el **Modo #2** y quieres usar los datos de esa db en otro archivo, debes de colocar los mismos datos especificando el **nombre**, **carpeta**, **sub** y **guardar_tiempo** (en caso de hayas usado estas propiedades)

Si tu base de datos se modifica muchas veces en pequeños lapsos de tiempo (supongamos cada 1 segundo) se recomienda usar la propiedad **guardar_tiempo** del **Modo #2**, esto hará que tu base de datos(archivo) no se llegue a reescribir/actualizar rapidamente, obtenemos una mejor fluidez al momento de guardar los datos. 


<a name="memoDB" />
### memoDB

El constructor memoDB te permitira crear una base de datos en memoria de forma eficiente.
Que quiere decir base de datos en memoria?
Practicamente los datos que agregues no se guardaran en un archivo ya que se mantendran en la memoria interna de este package, recuerda que los datos que agregues se perderan cada vez que tu proyecto/app se apague o reinicie.
Esto es perfecto para hacer cosas rapidas.


```js
memoDB(nombre_db)
```

__Argumentos__

1. nombre_db: Nombre de la base de datos, en caso de que quieras obtener los datos de esta db en otro archivo, solo debes de colocar el mismo nombre.

__Recuerda__

No habrá ningun problema si colocas el nombre de una base de datos que esta siendo usada en el constructor crearDB, ambas dbs guardaran datos por separado.

__Importante__

Este constructor puede usar unicamente los siguientes metodos:

- establecer
- obtener
- tiene
- eliminar
- purgeall
- sumar
- restar
- push
- extract
- datos
- ordenar
- random
- keys
- values
- size
- find
- filter
- map
- some
- setIndex
- delIndex
- findKey
- partition

__Ejemplos__

```js

//Ejemplo 1
const db = require('megadb');
let puntajes = new db.memoDB('niveles');
/*
Esto hará que se cree la base de datos niveles en la memoria interna
*/
```


<a name="establecer" />
### establecer

```js
establecer(clave, valor, clave_split)

//[alias]
set(clave, valor, clave_split)
```

Este metodo te permite crear propiedades mediante una clave, tambien te permite actualizar datos existentes por nuevos.

__Argumentos__

1. clave: Aqui deberas de poner el nombre de la propiedad que quieres crear, puedes usar el . seguido de otro nombre para crear o para acceder a propiedades anidadas (el . es un signo por default, puedes cambiarlo en clave_split)
2. valor: Aqui deberas de poner el valor que recibira la propiedad que especificaste en el argumento clave.
3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para crear o para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Promesa con los datos actualizados

__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

niveles.establecer('MegaStar', {xp: 0, nivel: 10}) // retorna una promesa: {MegaStar: {xp: 0, nivel: 10}}
niveles.establecer('MegaStar.xp', 100) // retorna una promesa: {MegaStar: {xp: 100, nivel: 10}}
niveles.establecer('MoDeR', 100) // retorna una promesa: {MegaStar: {xp: 100, nivel: 10}, MoDeR: 100}
niveles.establecer('MoDeR-datos-monedas', 200, "-") // retorna una promesa: {MegaStar: {xp: 100, nivel: 10}, MoDeR: {datos: {monedas: 200}}}
niveles.establecer('MoDeR.datos.banco', 1000) // retorna una promesa:{MegaStar: {xp: 100, nivel: 10}, MoDeR: {datos: {monedas: 200, banco: 1000}}}
niveles.establecer('RatSageM', []) // retorna una promesa: {MegaStar: {xp: 100, nivel: 10}, MoDeR: {datos: {monedas: 200, banco: 1000}}, RatSageM: []}

//Estructura de la base de datos niveles.json:
{
  "MegaStar": {
    "xp": 100,
    "nivel": 10
  },
  "MoDeR": {
    "datos": {
      "monedas": 200,
      "banco": 1000
    }
  },
  "RatSageM": []
}

```


<a name="size" />
### size

```js
size()
```

Este metodo te permite obtener el numero de valores(claves/keys) de una base de datos.

__Argumentos__

Ninguno

__Retorna__

Retorna el numero de valores de la base de datos(claves/keys).

__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

let length = niveles.size()
console.log(length) //Esto retorna 3 ya que solo hemos agregado 3 valores(claves): MegaStar, MoDeR y RatSageM
```


<a name="obtener" />
### obtener

```js
obtener(clave, clave_split)

//[alias]
get(clave, clave_split)
```

Este metodo te permite obtener los datos(valores) de una propiedad especifica.

__Argumentos__

1. clave: Aqui deberas de poner el nombre de la propiedad que quieres obtener, puedes usar el . seguido de otro nombre para acceder a propiedades anidadas (el . es un signo por default, puedes cambiarlo en clave_split)
2. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidada en el argumento clave (por default es el .)

__Retorna__

Promesa con los datos que se obtuvo, de lo contrario **undefined**.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)

__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

niveles.obtener('MegaStar') // retorna promesa: {xp: 100, nivel: 10}
niveles.obtener('MegaStar.nivel') // retorna promesa: 10
niveles.obtener('MoDeR-datos-banco', "-") // retorna promesa: 1000
niveles.obtener('Star') //retorna promesa: undefined
```


<a name="tiene" />
### tiene

```js
tiene(clave, clave_split)

//[alias]
has(clave, clave_split)
```

Este metodo te permite verificar si existe una propiedad especifica.

__Argumentos__

1. clave: Aqui deberas de poner el nombre de la propiedad que quieres verificar, puedes usar el . seguido de otro nombre para acceder a propiedades anidadas (el . es un signo por default, puedes cambiarlo en clave_split)
2. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidada en el argumento clave (por default es el .)

__Retorna__

1. true si la propiedad existe.
2. false si la propiedad no existe.

__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

niveles.tiene('MegaStar') // retorna true
niveles.tiene('Mario') // retorna false
niveles.tiene('MegaStar.monedas') // retorna false
niveles.tiene('MoDeR-datos-monedas', "-") // retorna true
```


<a name="eliminar" />
### eliminar

```js
eliminar(clave, clave_split)

//[alias]
delete(clave, clave_split)
```

Este metodo te permite eliminar una propiedad especifica.

__Argumentos__

1. clave: Aqui deberas de poner el nombre de la propiedad que quieres eliminar, puedes usar el . seguido de otro nombre para acceder a propiedades anidadas (el . es un signo por default, puedes cambiarlo en clave_split)
2. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidada en el argumento clave (por default es el .)

__Retorna__

1. true si la propiedad se elimino correctamente.
2. false si la propiedad no se elimino (no existe).

__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

niveles.eliminar('MegaStar.xp') //retorna true
niveles.eliminar('MoDeR.datos.banco') //retorna true
niveles.eliminar('Mario') //retorna false


niveles.tiene('MoDeR.datos.banco') // retorna false porque lo eliminamos
niveles.tiene('MegaStar.xp') // retorna false porque lo eliminamos

niveles.obtener('MegaStar') // retorna promesa: {nivel: 10}
niveles.obtener('MoDeR-datos', "-") // retorna promesa: {monedas: 200}


//Estructura actual de la base de datos niveles.json:
{
  "MegaStar": {
    "nivel": 10
  },
  "MoDeR": {
    "datos": {
      "monedas": 200
    }
  },
  "RatSageM": []
}

```


<a name="datos" />
### datos

```js
datos()
```

Este metodo regresa todas las propiedades de la base de datos, en otras palabras todos los datos.

__Argumentos__

Ninguno

__Retorna__

Promesa con todos los datos.


__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

niveles.datos().then(n => {
  console.log(n)
})

//console.log(n)
{
  "MegaStar": {
    "nivel": 10
  },
  "MoDeR": {
    "datos": {
      "monedas": 100
    }
  },
  "RatSageM": []
}
```

<a name="push" />
### push

```js
push(clave, valor, clave_split)
```

Este metodo te permite agregar un elemento a un array.

__Argumentos__

1. clave: Aqui deberas de poner el nombre de la propiedad a la que quieres agregar el elemento, puedes usar el . seguido de otro nombre para acceder a propiedades anidadas (el . es un signo por default, puedes cambiarlo en clave_split)
2. valor: Aqui deberas de poner el elemento que se agregara en el array que especificaste en el argumento clave.
3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Promesa con el array actualizado.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)

__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

niveles.push('RatSageM', 'manzana') // retorna promesa: ["manzana"]
niveles.establecer('MGstar', {items: ["platano"]})
//retorna promesa: {MegaStar: {nivel: 10}, MoDeR: {datos: {monedas: 100}}, RatSageM: ["manzana"], Mgstar: {items: ["platano"]}}

niveles.push('MGstar', 'sandia') // retorna Error (.catch)
niveles.push('MGstar.items', 'sandia') // retorna promesa: ["platano", "sandia"]


//Estructura actual de la base de datos niveles.json:
{
  "MegaStar": {
    "nivel": 10
  },
  "MoDeR": {
    "datos": {
      "monedas": 200
    }
  },
  "RatSageM": ["manzana"],
  "MGstar": {
    "items": ["platano", "sandia"]
  }
}
```


<a name="extract" />
### extract

```js
extract(clave, valor, clave_split)
```

Este metodo te permite remover un elemento especifico de un array.

__Argumentos__

1. clave: Aqui deberas de poner el nombre de la propiedad a la que quieres remover el elemento, puedes usar el . seguido de otro nombre para acceder a propiedades anidadas (el . es un signo por default, puedes cambiarlo en clave_split)
2. valor: Aqui deberas de poner el elemento que se removera del array que especificaste en el argumento clave.
3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Promesa con el array actualizado.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)


__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

niveles.extract('MGstar', 'platano') // retorna Error (.catch)
niveles.extract('RatSageM', 'manzana') // retorna promesa: []
niveles.extract('MGstar.items', 'platano') // retorna promesa: ["sandia"]
niveles.extract('MGstar.items', 'durazno') // retorna Error (.catch)


//Estructura actual de la base de datos niveles.json:
{
  "MegaStar": {
    "nivel": 10
  },
  "MoDeR": {
    "datos": {
      "monedas": 200
    }
  },
  "RatSageM": [],
  "MGstar": {
    "items": ["sandia"]
  }
}
```


<a name="sumar" />
### sumar

```js
sumar(clave, valor, clave_split)

//[alias]
add(clave, valor, clave_split)
```

Este metodo te permite sumar una cantidad especifica a una propiedad, el valor propiedad debe ser un numero.

__Argumentos__

1. clave: Aqui deberas de poner el nombre de la propiedad a la que quieres sumarle una cantidad especifica, puedes usar el . seguido de otro nombre para acceder a propiedades anidadas (el . es un signo por default, puedes cambiarlo en clave_split)
2. valor: Aqui deberas de poner la cantidad que se le sumara a la propiedad que especificaste en el argumento clave, esto debe ser un numero.
3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Promesa con el valor actualizado.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)


__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

niveles.establecer('Nelson', 20)
//retorna promesa: {MegaStar: {nivel: 10}, MoDeR: {datos: {monedas: 200}}, RatSageM: [], MGstar: {items: ["sandia"]}, Nelson: 20}

niveles.sumar('Nelson', 25) //retorna promesa: 45
niveles.establecer('Sun.datos.monedas', 10)
//retorna promesa: {MegaStar: {nivel: 10}, MoDeR: {datos: {monedas: 200}}, RatSageM: [], MGstar: {items: ["sandia"]}, Nelson: 20, Sun: {datos: {monedas: 10}}}

niveles.sumar('Sun.datos', 90) // retorna Error (.catch)
niveles.sumar('Sun-datos-monedas', 90, "-") // retorna promesa: 100

console.log(niveles.size()) //Esto imprime 6 ya que hemos agregado 6 valores(claves): MegaStar, MoDeR, RatSageM, MGstar, Nelson y Sun

//Estructura actual de la base de datos niveles.json:
{
  "MegaStar": {
    "nivel": 10
  },
  "MoDeR": {
    "datos": {
      "monedas": 200
    }
  },
  "RatSageM": [],
  "MGstar": {
    "items": ["sandia"]
  },
  "Nelson": 45,
  "Sun": {
    "datos": {
      "monedas": 100
    }
  }
}
```


<a name="restar" />
### restar

```js
restar(clave, valor, clave_split)

//[alias]
subtract(clave, valor, clave_split)
```

Este metodo te permite restar una cantidad especifica a una propiedad, el valor propiedad debe ser un numero.

__Argumentos__

1. clave: Aqui deberas de poner el nombre de la propiedad a la que quieres restarle una cantidad especifica, puedes usar el . seguido de otro nombre para acceder a propiedades anidadas (el . es un signo por default, puedes cambiarlo en clave_split)
2. valor: Aqui deberas de poner la cantidad que se le restara a la propiedad que especificaste en el argumento clave, esto debe ser un numero.
3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Promesa con el valor actualizado.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)


__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

niveles.restar('Nelson', 40) //retorna promesa: 5
niveles.restar('Sun.datos', 100) // retorna Error (.catch)
niveles.restar('Sun-datos-monedas', 100, "-") // retorna promesa: 0


//Estructura actual de la base de datos niveles.json:
{
  "MegaStar": {
    "nivel": 10
  },
  "MoDeR": {
    "datos": {
      "monedas": 200
    }
  },
  "RatSageM": [],
  "MGstar": {
    "items": ["sandia"]
  },
  "Nelson": 5,
  "Sun": {
    "datos": {
      "monedas": 0
    }
  }
}
```


<a name="keys" />
### keys

```js
keys(clave, clave_split)
```

Este metodo retorna un array con todos los nombres(keys) de las propiedades del objeto que especificaste.

__Argumentos__

1. clave (opcional): La clave es opcional, en el caso de que quieras obtener los nombres(keys) de un objeto especifico, puedes colocar el nombre del objeto. Si quieres obtener los nombres(keys) de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
En el caso de que directamente quieras obtener los nombres(keys) de una base de datos, no pongas ningun valor.

3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Promesa con un array que contiene los nombres de las propiedades(keys).

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)


__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

niveles.keys() //retorna promesa: ["MegaStar", "MoDeR", "RatSageM", "MGstar", "Nelson", "Sun"]
niveles.keys('MegaStar.nivel') // retorna Error (.catch)
niveles.keys('Sun.datos') ///retorna promesa: ["monedas"]
```


<a name="values" />
### values

```js
values(clave, clave_split)
```

Este metodo retorna un array con todos los valores de las propiedades del objeto que especificaste.

__Argumentos__

1. clave (opcional): La clave es opcional, en el caso de que quieras obtener los valores de un objeto especifico, puedes colocar el nombre del objeto. Si quieres obtener los valores de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
En el caso de que directamente quieras obtener los valores de una base de datos, no pongas ningun valor.

3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Promesa con un array que contiene los valores de las propiedades.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)


__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

niveles.values() //retorna promesa: [{nivel: 10}, {datos: {monedas: 200}}, [], {items: ["sandia"]}, {datos: {monedas:0}}]

niveles.values('MegaStar.nivel') // retorna Error (.catch)
niveles.values('Sun.datos') ///retorna promesa: [{monedas: 0}]
```


<a name="purgeall" />
### purgeall

```js
purgeall()
```

Este metodo te permite eliminar todos los datos de una base de datos especifica.

__Argumentos__

Ninguno

__Retorna__

1. true si se elimino todo correctamente.
2. false si no se elimino correctamente.

__Ejemplos__

```js
const db = require('megadb');
let niveles = new db.crearDB('niveles');

//Estructura actual de la base de datos niveles.json:
{
  "MegaStar": {
    "nivel": 10
  },
  "MoDeR": {
    "datos": {
      "monedas": 200
    }
  },
  "RatSageM": [],
  "MGstar": {
    "items": ["sandia"]
  },
  "Nelson": 5,
  "Sun": {
    "datos": {
      "monedas": 0
    }
  }
}


let status = niveles.purgeall()
console.log(status) //Esto retorna true

//Estructura actual de la base de datos niveles.json:
{} //No contiene nada ya que se elimino todo
```


<a name="ordenar" />
### ordenar

```js
ordenar(clave, valor, clave_split)

//[alias]
sort(clave, valor, clave_split)
```

Este metodo te permite ordenar las propiedad de un objeto de forma descendente, ten en cuenta que el valor de las propiedades que quieras ordenar debe ser un numero.

__Argumentos__

1. clave: La clave puede recibir dos tipos de valores, en el caso de que quieras ordenar las propiedades de un objeto especifico, puedes colocar el nombre del objeto. Si quieres ordenar las propiedades de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
Puedes usar false en caso de que directamente quieras ordenar las propiedades de una base de datos.

2. valor: El valor tambien puede recibir dos tipos de valores, en el caso de que las propiedades del objeto que quieres ordenar tambien sean objetos y mantengan propiedades, puedes colocar el nombre de la propiedad que se usara como referencia para ordenarlos de forma descendente, en el caso de que estas propiedades tambien sean objetos, puedes usar el . seguido del nombre del objeto y la propiedad que quieres ordenar (el . es un signo por default, puedes cambiarlo en clave_split)
Puedes usar false en caso de que el valor de la propiedad con la cual lo vas a ordenar no sea un objeto.

3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave y el argumento valor (por default es el .)

__Retorna__

Promesa con un array, este array contiene las propiedades ordenadas de forma descendente.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)


__Ejemplos__

```js
//ejemplo_1

const db = require('megadb');
let economia = new db.crearDB('guild_1', 'economia_db');

economia.establecer('MegaStar', 100)
economia.establecer('MoDeR', 40)
economia.establecer('ratsagem', 320)

/*
Estructura actual de la base de datos guild_1.json:

{
  "MegaStar": 100,
  "MoDeR": 40,
  "ratsagem": 320
}

*/

economia.ordenar(false, false)
//retorna promesa: [{clave: 'ratsagem', valor: 320}, {clave: 'MegaStar', valor: 100}, {clave: 'MoDeR', valor: 40}]


/////////////////////////////////////////////////////


//ejemplo_2
const db = require('megadb');
let economia = new db.crearDB('guild_1', 'economia_db');
economia.establecer('MegaStar', {monedas: 100})
economia.establecer('MoDeR', {monedas: 40})
economia.establecer('ratsagem', {monedas: 320})

/*
Estructura actual de la base de datos guild_1.json:

{
  "MegaStar": {
    "monedas": 100
  },
  "MoDeR": {
    "monedas": 40
  },
  "ratsagem": {
    "monedas": 320
  }
}

*/

economia.ordenar(false, "monedas")
//retorna promesa: [{clave: 'ratsagem', valor: {monedas: 320)}, {clave: 'MegaStar', valor: {monedas: 100}}, {clave: 'MoDeR', valor: {monedas: 40)}]


/////////////////////////////////////////////////////


//ejemplo_3
const db = require('megadb');
let economia = new db.crearDB('guild_2', 'economia_db');
let usuarios_data = {
  'MegaStar': 100,
  'MoDeR': 40,
  'ratsagem': 320
}
economia.establecer('usuarios', usuarios_data)

/*
Estructura actual de la base de datos guild_2.json:

{
  "usuarios": {
    "MegaStar": 100
    "MoDeR": 40
    "ratsagem": 320
  }
}

*/

economia.ordenar("usuarios", false)
//retorna promesa: [{clave: 'ratsagem', valor: 320}, {clave: 'MegaStar', valor: 100}, {clave: 'MoDeR', valor: 40}]


/////////////////////////////////////////////////////


//ejemplo_4
const db = require('megadb');
let economia = new db.crearDB('guild_3', 'economia_db');
let usuarios_data = {
  "MegaStar": {monedas: 50},
  "MoDeR": {monedas: 67},
  "ratsagem": {monedas: 4}
}
economia.establecer('usuarios', usuarios_data)


/*
Estructura actual de la base de datos guild_3.json:

{
  "usuarios": {
    "MegaStar": {
      "monedas": 50
    },
    "MoDeR": {
      "monedas": 67
    },
    "ratsagem": {
      "monedas": 4
    }
  }
}

*/

economia.ordenar("usuarios", "monedas")
//retorna promesa: [{clave: 'MoDeR', valor: {monedas: 67)}, {clave: 'MegaStar', valor: {monedas: 50}}, {clave: 'ratsagem', valor: {monedas: 4)}]


/////////////////////////////////////////////////////


//ejemplo_5
const db = require('megadb');
let economia = new db.crearDB('guild_4', 'economia_db');

let usuarios = {
  "megastar": {monedas: 10, medallas: 15},
  "moder": {monedas: 50, medallas: 20},
  "ratsagem": {monedas: 25, medallas: 5}
}
economia.establecer('servidores.datos', usuarios)

/*
Estructura actual de la base de datos guild_4.json:

{
 'servidores': {
    'datos': {
      'megastar': {
        'monedas': 10,
        'medallas': 15
      },
      'moder': {
        'monedas': 50,
        'medallas': 20
      },
      'ratsagem': {
        'monedas': 25,
        'medallas': 5
      }
    }
  }
}

*/

economia.ordenar('servidores.datos', "medallas")

/*
retorna promesa:

[
  {clave: 'moder', valor: {monedas: 50, medallas: 20}},
  {clave: 'MegaStar', valor: {monedas: 10, medallas: 15}},
  {clave: 'ratsagem', valor: {monedas: 25, medallas: 5}}
]

*/



/////////////////////////////////////////////////////


//ejemplo_6
const db = require('megadb');
let economia = new db.crearDB('guild_5', 'economia_db');

let usuarios = {
  "megastar": {stats: {monedas: 10}},
  "moder": {stats: {monedas: 50}},
  "ratsagem": {stats: {monedas: 25}}
}
economia.establecer('servidores.datos', usuarios)

/*
Estructura actual de la base de datos guild_5.json:

{
 'servidores': {
    'datos': {
      'megastar': {
        'stats': {
          'monedas': 10
        }
      },
      'moder': {
        'stats': {
          'monedas': 50
        }
      },
      'ratsagem': {
        'stats': {
          'monedas': 25
        }
      }
    }
  }
}

*/

economia.ordenar('servidores-datos', "stats-monedas", "-") //Estoy usando el - como separador en lugar del .

/*
retorna promesa:

[
  {clave: 'moder', valor: {stats: {monedas: 50}}},
  {clave: 'ratsagem', valor: {stats: {monedas: 25}}},
  {clave: 'megastar', valor: {stats: {monedas: 10}}}
]

*/
```


<a name="random" />
### random

```js
random(clave, cantidad, clave_split)
```

Este metodo te permite obtener una cantidad especifica de propiedades aleatoriamente (random), nunca se repetiran.

__Argumentos__

1. clave: La clave puede recibir dos tipos de valores, en el caso de que quieras obtener aleatoriamente una cantidad especifica de propiedades de un objeto, puedes colocar el nombre del objeto. Si quieres obtener aleatoriamente una cantidad especifica de propiedades de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
Puedes usar false en caso de que tengas propiedades que no sean objetos anidados.

2. cantidad: Aqui deberas de poner la cantidad(un numero) de propiedades random que se obtendra del objeto que especificaste en el argumento clave.
3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Promesa con un array, este array contiene las propiedades que fueron seleccionadas aleatoriamente.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)


__Ejemplos__

```js
//ejemplo_1
const db = require('megadb');
let giveaway = new db.crearDB('giveaway');

giveaway.establecer('MegaStar', {ganadas: 0})
giveaway.establecer('MoDeR', {ganadas: 0})
giveaway.establecer('ratsagem', {ganadas: 0})
giveaway.establecer('Sun', {ganadas: 0})
giveaway.establecer('MGstar', {ganadas: 0})
giveaway.establecer('ruru', {ganadas: 0})

//Estructura actual de la base de datos giveaway.json:
{
  "MegaStar": {
    "ganadas": 0
  },
  "MoDeR": {
    "ganadas": 0
  },
  "ratsagem": {
    "ganadas": 0
  },
  "pedro": {
    "ganadas": 0
  },
  "MGstar": {
    "ganadas": 0
  },
  "ruru":  {
    "ganadas": 0
  }
}

giveaway.random(false, 4)
//retorna una promesa (las propiedades son aleatorias, esto es solo un ejemplo):
/*

[
  {clave: MegaStar, valor: {ganadas: 0}},
  {clave: ruru, valor: {ganadas: 0}},
  {clave: pedro, valor: {ganadas: 0}},
  {clave: MoDeR, valor: {ganadas: 0}}
]

*/


/////////////////////////////////////////////////////


//ejemplo_2
const db = require('megadb');
let giveaway = new db.crearDB('giveaway1');
let usuarios = {
  "12132131231242343": {ganadas: 0},
  "12132454545454543": {ganadas: 2},
  "13243242342342343": {ganadas: 1},
  "12138786867868683": {ganadas: 6},
  "18989896797978973": {ganadas: 0},
  "12121212135345346":  {ganadas: 5}
}
giveaway.establecer('users_ID', usuarios)


//Estructura actual de la base de datos giveaway1.json:
{
  "users_ID": {
    "12132131231242343": {
      "ganadas": 0
    },
    "12132454545454543": {
      "ganadas": 2
    },
    "13243242342342343": {
      "ganadas": 1
    },
    "12138786867868683": {
      "ganadas": 6
    },
    "18989896797978973": {
      "ganadas": 0
    },
    "12121212135345346":  {
      "ganadas": 5
    }
  }
}

giveaway.random("users_ID", 3)
//retorna una promesa (las propiedades son aleatorias, esto es solo un ejemplo):
/*

[
  {clave: 13243242342342343, valor: {ganadas: 1}},
  {clave: 12138786867868683, valor: {ganadas: 6}},
  {clave: 12121212135345346, valor: {ganadas: 5}}
]

*/
```

<a name="existeDB" />
### existeDB

```js
existeDB(nombre_db)
```

Este metodo te permite verificar si existe una especifica base de datos en la carpeta mega_databases o en sub directorio.

__Argumentos__

1. nombre_db: Aqui debe de ir el nombre de la base de datos que quires verificar si existe, si usaste la opcion del sub directorio en el constructor crearDB, esto automaticamente buscara en el sub directorio, de lo contrario se buscara en la carpeta mega_databases si no usaste esta opcion.

__Retorna__

1. true si la base de datos existe.
2. false si la base de datos no existe.

__Ejemplos__

```js
/*
Nuestra estructura de dbs deberia ser esta:

[–] node_modules
[+] mega_databases
    [+] economia_db
        - guild_1.json
        - guild_2.json
        - guild_3.json
        - guild_4.json
        - guild_5.json
    - niveles.json
    - giveaway.json
    - giveaway1.json
*/

//ejemplo_1 usare un sub directorio
const db = require("megadb");
let economia = new db.crearDB("guild_1", "economia_db") //Estoy obteniendo el archivo guild_1.json que esta dentro del sub directorio "economia_db"
console.log(economia.existeDB("guild_2")) //retorna true
console.log(economia.existeDB("guild_5")) //retorna true
console.log(economia.existeDB("guild_8")) //retorna false
console.log(economia.existeDB("niveles")) //retorna false


//ejemplo_2 sin usar sub directorio
const db = require("megadb");
let niveles = new db.crearDB("niveles") //Estoy obteniendo el archivo niveles.json que esta dentro de la carpeta mega_databases
console.log(niveles.existeDB("giveaway")) //retorna true
console.log(niveles.existeDB("giveaway1")) //retorna true
console.log(niveles.existeDB("guild_8")) //retorna false
console.log(niveles.existeDB("mydb")) //retorna false
```


<a name="find" />
### find

```js
find(clave, callback(), clave_split)
```

Este metodo retorna el valor de la primera propiedad que cumpla la condicion del callback, si no encuentra nada regresara **undefined**.
Es similar al **Array.find**

__Argumentos__

1. clave: La clave puede recibir dos tipos de valores, en el caso de que quieras buscar en las propiedades de un objeto especifico, puedes colocar el nombre del objeto. Si quieres buscar en las propiedades de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
Puedes usar false en caso de que directamente quieras buscar en las propiedades de una base de datos.

2. callback(valor_actual, clave_actual) : Aqui deberas de poner la funcion que se ejecutara o evaluara sobre cada elemento iterado del objeto que especificaste en el argumento clave, el callback puede recibir 2 argumentos:

```
valor_actual (opcional): Aqui se mostrara el valor del elemento que se esta procesando en ese momento.
clave_actual (opcional): Aqui se mostrara la clave del elemento que se esta procesando en ese momento.
```

3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Esto retornara una promesa con el valor de la primera propiedad que cumpla la condicion del callback, de lo contrario retornara **undefined**.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)

__Ejemplos__

```js

//ejemplo_1
const db = require("megadb");
let escuela = new db.crearDB("escuela")

escuela.establecer('Mario', {edad: 15, apellido: "garcia"})
escuela.establecer('Pedro', {edad: 12, apellido: "rojas"})
escuela.establecer('Juan', {edad: 10, apellido: "perez"})
escuela.establecer('Jair', {edad: 16, apellido: "gonzales"})

/* Estructura actual de la base de datos escuela.json:

{
  "Mario": {
    "edad: 15,
    "apellido: "garcia"
  },
  "Pedro": {
    "edad: 12,
    "apellido: "rojas"
  },
  "Juan": {
    "edad: 10,
    "apellido: "perez"
  },
  "Jair": {
    "edad: 16,
    "apellido: "gonzales"
  }
}

*/

escuela.find(false, (v) => v.edad == 16).then(nuevos => { //v es el elemento que se esta procesando en ese momento

  /* Ahora nuevos debera de contener esto:
    {
      "edad": "16",
      "apellido": "gonzales"
    }
  */

  if(nuevos == undefined) return console.log("Ningun alumno tiene 16 años")
  return console.log(`El alumno ${nuevos.apellido} tiene ${nuevos.edad} años!`)
}).catch(error => console.log(error))

//Esto da como resultado: "El alumno gonzales tiene 16 años!"


/////////////////////////////////////////////////////


//ejemplo_2
const db = require("megadb");
let registros = new db.crearDB("registros")

let registrados = {
  "ID_1": {
    "username": "MegaStar",
    "password": "xxxxxxxx",
    "age": 20
  },
  "ID_2": {
    "username": "MoDeR",
    "password": "aaaaaaaa",
    "age": 19
  },
  "ID_3": {
    "username": "RatSageM",
    "password": "cccccccc",
    "age": 18
  }
}

registros.establecer('usuarios', registrados)

/* Estructura actual de la base de datos registros.json:

{
  "usuarios": {
    "ID_1": {
      "username": "MegaStar",
      "password": "xxxxxxxx",
      "edad": 20
    },
    "ID_2": {
      "username": "MoDeR",
      "password": "aaaaaaaa",
      "edad": 19
    },
    "ID_3": {
      "username": "RatSageM",
      "password": "cccccccc",
      "edad": 18
    }
  }
}

*/

registros.find("usuarios", (v) => v.username == "MegaStar").then(usuario => { //v es el elemento del objeto "usuarios" que se esta procesando en ese momento

  /* Ahora usuario debera de contener esto:
    {
      "username": "MegaStar",
      "password": "xxxxxxxx",
      "edad": 20
    }
  */

  if(usuario == undefined) return console.log("No existe este usuario.")
  let nombre = usuario.username
  let contra = usuario.password
  let edad = usuario.edad
  return console.log(`Datos, username: ${nombre}, contraseña: ${contra}, edad: ${edad}`)
}).catch(error => console.log(error))

//Esto da como resultado: "Datos, username: MegaStar, contraseña: xxxxxxxx, edad: 20"
```


<a name="filter" />
### filter

```js
filter(clave, callback(), clave_split)
```

Este metodo retorna un objeto con todas las propiedades que cumplan la condicion del callback, si no encuentra nada regresara un objeto vacio **{}**.
Es similar al **Array.filter** solo que en vez de regresar un nuevo array, regresa un nuevo objeto.

__Argumentos__

1. clave: La clave puede recibir dos tipos de valores, en el caso de que quieras buscar en las propiedades de un objeto especifico, puedes colocar el nombre del objeto. Si quieres buscar en las propiedades de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
Puedes usar false en caso de que directamente quieras buscar en las propiedades de una base de datos.

2. callback(valor_actual, clave_actual): Aqui deberas de poner la funcion que se ejecutara o evaluara sobre cada elemento iterado del objeto que especificaste en el argumento clave, el callback puede recibir 2 argumentos:

```
valor_actual (opcional): Aqui se mostrara el valor del elemento que se esta procesando en ese momento.
clave_actual (opcional): Aqui se mostrara la clave del elemento que se esta procesando en ese momento.
```

3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Esto retornara una promesa con un objeto que contiene todas las propiedades que cumplan la condicion del callback, de lo contrario retornara un objeto vacio **{}**.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)

__Ejemplos__

```js

//ejemplo_1
const db = require("megadb");
let seleccion = new db.crearDB("seleccion")

seleccion.establecer('Mario', 18)
seleccion.establecer('Pedro', 20)
seleccion.establecer('Juan', 12)
seleccion.establecer('Jair', 13)
seleccion.establecer('Steve', 16)
seleccion.establecer('Axel', 10)

/* Estructura actual de la base de datos seleccion.json:

{
  "Mario": 18,
  "Pedro": 20,
  "Juan": 12,
  "Jair": 13,
  "Steve": 16,
  "Axel": 10
}

*/

seleccion.filter(false, (v) => v > 15).then(nuevos => { //Estoy especificando que el valor del elemento que se esta procesando sea mayor a 15

  /* Ahora nuevos debera de contener este objeto:
    {
      "Mario": 18,
      "Pedro": 20,
      "Steve": 16
    }
  */

  if(Object.keys(nuevos).length <= 0) return console.log("Ningun jugador tiene mas de 15 años")
  let jugadores = []
  for(var key in nuevos) {
    jugadores.push(`Nombre: ${key}, edad: ${nuevos[key]}`)
  }
  return console.log(jugadores.join("\n"))
})

/*Esto da como resultado:

Nombre: Mario, edad: 18
Nombre: Pedro, edad: 20
Nombre: Steve, edad: 16

*/


/////////////////////////////////////////////////////


//ejemplo_2
const db = require("megadb");
let registros2 = new db.crearDB("registros2")

let registrados = {
  "ID_1": {
    "username": "MegaStar",
    "password": "xxxxxxxx",
    "lenguaje": "javascript"    
    "age": 20
  },
  "ID_2": {
    "username": "MoDeR",
    "password": "aaaaaaaa",
    "lenguaje": "javascript"    
    "age": 19
  },
  "ID_3": {
    "username": "RatSageM",
    "password": "cccccccc",
    "lenguaje": "c++"    
    "age": 18
  }
}

registros2.establecer('users', registrados)

/* Estructura actual de la base de datos registros2.json:

{
  "users": {
    "ID_1": {
      "username": "MegaStar",
      "password": "xxxxxxxx",
      "lenguaje": "javascript"       
      "edad": 20
    },
    "ID_2": {
      "username": "MoDeR",
      "password": "aaaaaaaa",
      "lenguaje": "javascript"       
      "edad": 19
    },
    "ID_3": {
      "username": "RatSageM",
      "password": "cccccccc",
      "lenguaje": "c++"     
      "edad": 18
    }
  }
}

*/

registros2.filter("users", (v) => v.lenguaje == "javascript").then(usuarios => {

  /* Ahora usuarios debera de contener este objeto:
    {
      "ID_1": {
        "username": "MegaStar",
        "password": "xxxxxxxx",
        "lenguaje": "javascript"       
        "edad": 20
      },
      "ID_2": {
        "username": "MoDeR",
        "password": "aaaaaaaa",
        "lenguaje": "javascript"       
        "edad": 19
      }
    }
  */
  if(Object.keys(usuarios).length <= 0) return console.log("Ningun usuario sabe javascript.")
  let lista = []

  for(var key in usuarios) {
    let nombre = usuarios[key].username
    let edad = usuarios[key].edad
    let lenguaje = usuarios[key].lenguaje

    lista.push(`[${key}] username: ${nombre}, edad: ${edad}, lenguaje: ${lenguaje}`)
  }
  return console.log(lista.join("\n"))
})

/*Esto da como resultado:

[ID_1] username: MegaStar, edad: 20, lenguaje: javascript
[ID_2] username: MoDeR, edad: 18, lenguaje: javascript

*/
```


<a name="map" />
### map

```js
map(clave, callback(), clave_split)
```

Este metodo retorna un array con los resultados de la condicion que se especifico en el callback.
Es similar al **Array.map**

__Argumentos__

1. clave: La clave puede recibir dos tipos de valores, en el caso de que quieras buscar en las propiedades de un objeto especifico, puedes colocar el nombre del objeto. Si quieres buscar en las propiedades de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
Puedes usar false en caso de que directamente quieras buscar en las propiedades de una base de datos.

2. callback(valor_actual, clave_actual): Aqui deberas de poner la funcion que se ejecutara o evaluara sobre cada elemento iterado del objeto que especificaste en el argumento clave, el callback puede recibir 2 argumentos:

```
valor_actual (opcional): Aqui se mostrara el valor del elemento que se esta procesando en ese momento.
clave_actual (opcional): Aqui se mostrara la clave del elemento que se esta procesando en ese momento.
```

3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Esto retornara una promesa con un array que contiene todos los resultados que se especificó en el callback.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)

__Ejemplos__

```js

//ejemplo_1
const db = require("megadb");
let puntaje = new db.crearDB("puntajes")

puntaje.establecer('Mario', 2)
puntaje.establecer('Pedro', 4)
puntaje.establecer('Juan', 5)
puntaje.establecer('Jair', 6)

/* Estructura actual de la base de datos puntajes.json:

{
  "Mario": 2,
  "Pedro": 4,
  "Juan": 5,
  "Jair": 6
}

*/

puntaje.map(false, (v, key) => `Usuario: ${key}, puntaje: ${v*2}`).then(datos => { //v toma el valor del elemento que se esta procesando en ese momento, y key toma la clave del elemento que se esta procesando en ese momento

  /* Ahora datos debera de contener este array:

    ["Usuario: Mario, puntaje: 4",
     "Usuario: Pedro, puntaje: 8",
     "Usuario: Juan, puntaje: 10",
     "Usuario: Jair, puntaje: 12"]
  */

  return console.log(datos.join("\n"))
})

/*Esto da como resultado:

Usuario: Mario, puntaje: 4
Usuario: Pedro, puntaje: 8
Usuario: Juan, puntaje: 10
Usuario: Jair, puntaje: 12

*/


/////////////////////////////////////////////////////


//ejemplo_2
const db = require("megadb");
let users_lb = new db.crearDB("userslb")

let usuarios = {
  "servidor_1": {
    "MegaStar": 8,   
    "MoDeR": 6,
    "Mario": 1,
    "Pedro": 8
  },
  "servidor_2": {
    "Juan": 4,   
    "RatSageM": 5,
    "Steve": 7
  },
  "servidor:3": {
    "reDoM": 1,
    "Jack": 4
  }
}

users_lb.establecer('leaderboard', usuarios)

/* Estructura actual de la base de datos userslb.json:

{
  "leaderboard": {
    "servidor_1": {
      "MegaStar": 8,   
      "MoDeR": 6,
      "Mario": 1,
      "Pedro": 8
    },
    "servidor_2": {
      "Juan": 4,   
      "RatSageM": 5,
      "Steve": 7
    },
    "servidor_3": {
      "reDoM": 1,
      "Jack": 4
    }
  }
}

*/

users_lb.map("leaderboard.servidor_1", (v, key) => `Usuario: ${key} | puntos: ${v*3}`).then(usuarios => {

  /* Ahora usuarios debera de contener este array:

  ["Usuario: MegaStar | puntos: 24",
   "Usuario: MoDeR | puntos: 18",
   "Usuario: Mario | puntos: 3",
   "Usuario: Pedro | puntos: 24"]

  */

  return console.log(usuarios.join("\n"))
})

/*Esto da como resultado:

Usuario: MegaStar | puntos: 24
Usuario: MoDeR | puntos: 18
Usuario: Mario | puntos: 3
Usuario: Pedro | puntos: 24

*/
```


<a name="some" />
### some

```js
some(clave, callback(), clave_split)
```
Este metodo comprueba si al menos una propiedad del objeto(la base de datos) cumple con la condicion que se especificó en el callback.
Es similar al **Array.some**

__Argumentos__

1. clave: La clave puede recibir dos tipos de valores, en el caso de que quieras buscar en las propiedades de un objeto especifico, puedes colocar el nombre del objeto. Si quieres buscar en las propiedades de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
Puedes usar false en caso de que directamente quieras buscar en las propiedades de una base de datos.

2. callback(valor_actual, clave_actual): Aqui deberas de poner la funcion que se ejecutara o evaluara sobre cada elemento iterado del objeto que especificaste en el argumento clave, el callback puede recibir 2 argumentos:

```
valor_actual (opcional): Aqui se mostrara el valor del elemento que se esta procesando en ese momento.
clave_actual (opcional): Aqui se mostrara la clave del elemento que se esta procesando en ese momento.
```

3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Esto retornara true si al menos una propiedad del objeto cumple con la condicion del callback se cumple, de lo contrario retornara false.


__Ejemplos__

```js

//ejemplo_1
const db = require("megadb");
let puntaje = new db.crearDB("puntajes")

puntaje.establecer('Mario', 2)
puntaje.establecer('Pedro', 4)
puntaje.establecer('Juan', 5)
puntaje.establecer('Jair', 6)

/* Estructura actual de la base de datos puntajes.json:

{
  "Mario": 2,
  "Pedro": 4,
  "Juan": 5,
  "Jair": 6
}

*/

let verificar = puntaje.some(false, (v) => v == 6)
if(verificar) {
  console.log("Un usuario tiene 6 puntos.")
}
else{
  console.log("Ningun usuario tiene 6 puntos.")
}

/*Esto da como resultado:
"Un usuario tiene 6 puntos"

*/


/////////////////////////////////////////////////////


//ejemplo_2
const db = require("megadb");
let users_lb = new db.crearDB("userspt")

let usuarios = {
  "user001": {
    "nombre": "MegaStar",   
    "puntos": 10
  },
  "user002": {  
    "nombre": "Juan",   
    "puntos": 4
  },
  "user003": {
    "nombre": "reDoM",   
    "puntos": 2
  }
}

users_lb.establecer('leaderboard', usuarios)

/* Estructura actual de la base de datos userspt.json:

{
  "leaderboard": {
    "user001": {
      "nombre": "MegaStar",   
      "puntos": 10
    },
    "user002": {  
      "nombre": "Juan",   
      "puntos": 4
    },
    "user003": {
      "nombre": "reDoM",   
      "puntos": 3
    }
  }
}

*/

console.log(users_lb.some("leaderboard", (v) => v.nombre == "MegaStar")) // retorna true
console.log(users_lb.some("leaderboard", (v) => v.nombre == "MoDeR")) // retorna false
console.log(users_lb.some("leaderboard", (v) => v.puntos > 5)) // retorna true
```


<a name="setIndex" />
### setIndex

```js
setIndex(clave, index, valor, clave_split)
```
Este metodo te permite remplazar un elemento especifico de un array a travez de su index (posicion).


__Argumentos__

1. clave: La clave puede recibir dos tipos de valores, en el caso de que quieras buscar en las propiedades de un objeto especifico, puedes colocar el nombre del objeto. Si quieres buscar en las propiedades de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
Puedes usar false en caso de que directamente quieras buscar en las propiedades de una base de datos.

2. index: Aqui deberas de poner el indice(index) del elemento que quieres remplazar en el array, esto es un numero.

3. valor: Aqui deberas de colocar el nuevo valor que tomará el elemento del indice(index) que especificaste en el parametro **index**

4. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Promesa con el array actualizado.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)

__Ejemplos__

```js

//ejemplo_1
const db = require("megadb");
let mercado_db = new db.crearDB("mercado")

mercado_db.establecer('frutas', [
  "platano",
  "durazno",
  "manzana",
  "zanahoria"
])

/* Estructura actual de la base de datos mercado.json:
{
  "frutas": [
    "platano",
    "durazno",
    "manzana",
    "zanahoria"
  ]
}

*/

mercado_db.setIndex("frutas", 3, "piña") // retorna promesa: ["platano", "durazno", "manzana", "piña"]
```


<a name="delIndex" />
### delIndex

```js
delIndex(clave, index, clave_split)
```
Este metodo te permite remover un elemento especifico de un array a travez de su index (posicion).


__Argumentos__

1. clave: La clave puede recibir dos tipos de valores, en el caso de que quieras buscar en las propiedades de un objeto especifico, puedes colocar el nombre del objeto. Si quieres buscar en las propiedades de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
Puedes usar false en caso de que directamente quieras buscar en las propiedades de una base de datos.

2. index: Aqui deberas de poner el indice(index) del elemento que quieres remover del array, esto es un numero.

3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Promesa con el array actualizado.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)

__Ejemplos__

```js

//ejemplo_1
const db = require("megadb");
let mercado_db = new db.crearDB("mercado")

mercado_db.establecer('frutas', [
  "platano",
  "durazno",
  "manzana",
  "zanahoria"
])

/* Estructura actual de la base de datos mercado.json:
{
  "frutas": [
    "platano",
    "durazno",
    "manzana",
    "zanahoria"
  ]
}

*/

mercado_db.delIndex("frutas", 3) // retorna promesa: ["platano", "durazno", "manzana"]

/////////////////////////////////////////////////////


//ejemplo_2

const db = require("megadb");
let economy_db = new db.crearDB("economydb")

economy_db.establecer("usuarios", [
  {nombre: "megastar"},
  {nombre: "moder"},
  {nombre: "pedro"}
])

/* Estructura actual de la base de datos economydb.json:

{
  "usuarios": [
    {"nombre": "megastar"},
    {"nombre": "moder"},
    {"nombre": "pedro"}
  ]
}

*/
economy_db.obtener("usuarios").then(usuarios => {
  let index = usuarios.findIndex(u => u.nombre == "pedro")
  if(index != -1) {
    economy_db.delIndex("usuarios", index).then(nuevo_array => {
      console.log(nuevo_array)
    }).catch(error => console.log(error))
  }
  else{
    console.log("No hay ningun usuario con el nombre pedro.")
  }
}).catch(error => console.log(error))

/*
Resultado:

[
  {"nombre": "megastar"},
  {"nombre": "moder"}
]
```


<a name="findKey" />
### findKey

```js
findKey(clave, callback(), clave_split)
```

Este metodo retorna la clave de la primera propiedad que cumpla la condicion del callback, si no encuentra nada regresara **undefined**.
Es similar al **Array.findIndex**, solo que en vez de retornar el indice, regresa la clave.

__Argumentos__

1. clave: La clave puede recibir dos tipos de valores, en el caso de que quieras buscar en las propiedades de un objeto especifico, puedes colocar el nombre del objeto. Si quieres buscar en las propiedades de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
Puedes usar false en caso de que directamente quieras buscar en las propiedades de una base de datos.

2. callback(valor_actual, clave_actual) : Aqui deberas de poner la funcion que se ejecutara o evaluara sobre cada elemento iterado del objeto que especificaste en el argumento clave, el callback puede recibir 2 argumentos:

```
valor_actual (opcional): Aqui se mostrara el valor del elemento que se esta procesando en ese momento.
clave_actual (opcional): Aqui se mostrara la clave del elemento que se esta procesando en ese momento.
```

3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Esto retornara una promesa con la clave de la primera propiedad que cumpla la condicion del callback, de lo contrario retornara **undefined**.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)

__Ejemplos__

```js

//ejemplo_1
const db = require("megadb");
let escuela = new db.crearDB("escuela")

escuela.establecer('Mario', {edad: 15, apellido: "garcia"})
escuela.establecer('Pedro', {edad: 12, apellido: "rojas"})
escuela.establecer('Juan', {edad: 10, apellido: "perez"})
escuela.establecer('Jair', {edad: 16, apellido: "gonzales"})

/* Estructura actual de la base de datos escuela.json:

{
  "Mario": {
    "edad: 15,
    "apellido: "garcia"
  },
  "Pedro": {
    "edad: 12,
    "apellido: "rojas"
  },
  "Juan": {
    "edad: 10,
    "apellido: "perez"
  },
  "Jair": {
    "edad: 16,
    "apellido: "gonzales"
  }
}

*/

escuela.findKey(false, (v) => v.edad == 16).then(alumno => { //v es el elemento que se esta procesando en ese momento

  //Ahora alumno debera de contener 'Jair'
    
  if(alumno == undefined) return console.log("Ningun alumno tiene 16 años")
  return console.log(`El alumno ${alumno} tiene 16 años!`)
}).catch(error => console.log(error))

//Esto da como resultado: "El alumno Jair tiene 16 años!"


/////////////////////////////////////////////////////


//ejemplo_2
const db = require("megadb");
let registros = new db.crearDB("registros")

let registrados = {
  "ID_1": {
    "username": "MegaStar",
    "password": "xxxxxxxx",
    "age": 20
  },
  "ID_2": {
    "username": "MoDeR",
    "password": "aaaaaaaa",
    "age": 19
  },
  "ID_3": {
    "username": "RatSageM",
    "password": "cccccccc",
    "age": 18
  }
}

registros.establecer('usuarios', registrados)

/* Estructura actual de la base de datos registros.json:

{
  "usuarios": {
    "ID_1": {
      "username": "MegaStar",
      "password": "xxxxxxxx",
      "edad": 20
    },
    "ID_2": {
      "username": "MoDeR",
      "password": "aaaaaaaa",
      "edad": 19
    },
    "ID_3": {
      "username": "RatSageM",
      "password": "cccccccc",
      "edad": 18
    }
  }
}

*/

registros.findKey("usuarios", (v) => v.username == "MegaStar").then(id => { //v es el elemento del objeto "usuarios" que se esta procesando en ese momento

  // Ahora id debera de contener 'ID_1'
   

  if(id == undefined) return console.log("No existe este usuario.")
  return console.log(`El ID del usuario MegaStar es: ${id}`)
}).catch(error => console.log(error))

//Esto da como resultado: "El ID del usuario MegaStar es: ID_1"
```


<a name="partition" />
### partition

```js
partition(clave, callback(), clave_split)
```

Este metodo divide un objeto(base de datos) en dos objetos donde el primer objeto contiene las propiedades que cumplan con la condicion del callback y el segundo objeto con las propiedades que no la condicion.

__Argumentos__

1. clave: La clave puede recibir dos tipos de valores, en el caso de que quieras buscar en las propiedades de un objeto especifico, puedes colocar el nombre del objeto. Si quieres buscar en las propiedades de un objeto anidado, puedes usar el . seguido del nombre del objeto anidado (el . es un signo por default, puedes cambiarlo en clave_split)
Puedes usar false en caso de que directamente quieras buscar en las propiedades de una base de datos.

2. callback(valor_actual, clave_actual) : Aqui deberas de poner la funcion que se ejecutara o evaluara sobre cada elemento iterado del objeto que especificaste en el argumento clave, el callback puede recibir 2 argumentos:

```
valor_actual (opcional): Aqui se mostrara el valor del elemento que se esta procesando en ese momento.
clave_actual (opcional): Aqui se mostrara la clave del elemento que se esta procesando en ese momento.
```

3. clave_split (opcional): Este argumento es opcional, aqui puedes especificar el signo que se usara para acceder a propiedades anidadas en el argumento clave (por default es el .)

__Retorna__

Esto retornara un **Array** con dos elementos, el primer elemento seria un objeto con las propiedades que cumplieron con la condicion del callback y el segundo elemento un objeto con las que no lo cumplieron.

__Error__

En caso de que ocurra un error, esto regresara un objeto con el error descriptivo *(puedes obtenerlo con un .catch(error => ))*
[Click aqui para ver los tipos de errores](#Errores)

__Ejemplos__

```js

//ejemplo_1
const db = require("megadb");
let clases_rpg = new db.crearDB("rpg")

clases_rpg.establecer('Mario', {hp: 200, clase: "enano"})
clases_rpg.establecer('MoDeR', {hp: 200, clase: "enano"})
clases_rpg.establecer('MegaStar', {hp: 100, clase: "elfo"})
clases_rpg.establecer('ratsagem', {hp: 100, clase: "elfo"})

/* Estructura actual de la base de datos rpg.json:

{
  "Mario": {
    "hp: 200,
    "clase: "enano"
  },
  "Pedro": {
    "hp: 200,
    "clase: "enano"
  },
  "MegaStar": {
    "hp: 100,
    "clase: "elfo"
  },
  "ratsagem": {
    "hp: 100,
    "clase: "elfo"
  }
}

*/

//Usando (async/await)
let [enanos, elfos] = await clases_rpg.partition(false, (v) => v.clase == 'enano')
console.log(`Usuarios de clase enano: ${Object.keys(enanos).join(", ")}\nUsuarios de clase elfo: ${Object.keys(elfos).join(", ")}`)

//usando then/catch
clases_rpg.partition(false, (v) => v.clase == 'enano').then(clases => { //v es el elemento que se esta procesando en ese momento
  let [enanos, elfos] = clases

  console.log(`Usuarios de clase enano: ${Object.keys(enanos).join(", ")}\nUsuarios de clase elfo: ${Object.keys(elfos).join(", ")}`)
}).catch(error => console.log(error))

/*Esto da como resultado:

Usuarios de clase enano: Mario, MoDeR
Usuarios de clase elfo: MegaStar, ratsagem

Si imprimimos:
- console.log(enanos)
{
  Mario: { hp: 200, clase: 'enano' },
  MoDeR: { hp: 200, clase: 'enano' }
}

- console.log(elfos)
{
  MegaStar: { hp: 100, clase: 'elfo' },
  ratsagem: { hp: 100, clase: 'elfo' }
}
*/

/////////////////////////////////////////////////////


//ejemplo_2
const db = require("megadb");
let clases_rpg = new db.crearDB("rpg")

let jugadores = {
  "ID_1": {
    "username": "MegaStar",
    "hp": 100,
    "clase": "elfo"
  },
  "ID_2": {
    "username": "MoDeR",
    "hp": 200,
    "clase": "enano"
  },
  "ID_3": {
    "username": "ratsagem",
    "hp": 100,
    "clase": "elfo"
  }
}

clases_rpg.establecer('servidor1', jugadores)

/* Estructura actual de la base de datos rpg.json:
{
  "servidor1": {
    "ID_1": {
      "username": "MegaStar",
      "hp": 100,
      "clase": "elfo"
    },
    "ID_2": {
      "username": "MoDeR",
      "hp": 200,
      "clase": "enano"
    },
    "ID_3": {
      "username": "ratsagem",
      "hp": 100,
      "clase": "elfo"
    }
  }
}
*/


//Usando (async/await)
let [enanos, elfos] = await clases_rpg.partition("servidor1", (v) => v.clase == 'enano')
console.log(`Usuarios de clase enano: ${enanos.map(e => e.username).join(", ")}\nUsuarios de clase elfo: ${elfos.map(e => e.username).join(", ")}`)
//usando then/catch
clases_rpg.partition("servidor1", (v) => v.clase == 'enano').then(clases => { //v es el elemento que se esta procesando en ese momento
  let [enanos, elfos] = clases

  console.log(`Usuarios de clase enano: ${enanos.map(e => e.username).join(", ")}\nUsuarios de clase elfo: ${elfos.map(e => e.username).join(", ")}`)
}).catch(error => console.log(error))

/*Esto da como resultado:

Usuarios de clase enano: MoDeR
Usuarios de clase elfo: MegaStar, ratsagem

Si imprimimos:
- console.log(enanos)
{
   ID_2: { username: 'MoDeR', hp: 200, clase: 'enano' }
}

- console.log(elfos)
{
  ID_1: { username: 'MegaStar', hp: 100, clase: 'elfo' },
  ID_3: { username: 'ratsagem', hp: 100, clase: 'elfo' }
}
*/
```


<a name="convert_megadtbs" />
### convert_megadtbs

```js
convert_megadtbs()
```

Este metodo es especial, usalo solo cuando quieras adaptar tu base de datos del npm mega-dtbs al megadb.
Para adaptar tu base de datos del mega-dtbs a megadb, debes de poner el nombre "mega_db" en el constructor crearDB.
Asegurate de que el archivo mega_db.json se encuentre dentro de la carpeta mega_databases.

__Argumentos__

Ninguno.

__Retorna__

Nada.

__Demostracion__

https://youtu.be/rouyoy0SJN0

__Ejemplos__

```js
const db = require("megadb");
let megadb = new db.crearDB("mega_db")
megadb.convert_megadtbs()
```


<a name="Errores" />
## Errores

Estructura del error:

1. name: [MEGADB ERROR].
2. message: El mensaje descriptivo del error.
3. type: El tipo de error que se produjo.
4. method: El metodo en el que se produjo el error.
5. param1: El valor ingresado en el primer argumento del metodo usado.
6. param2: El valor ingresado en el segundo argumento del metodo usado(si tiene).
7: reference: Una referencia a como actualmente se está usando el metodo.


__Ejemplos__

```js
const db = require("megadb");
let paises = new db.crearDB("paises")
paises.establecer("norte", ["argentina", "brasil", "colombia"]) //retorna promesa: {norte: ["argentina", "brasil", "colombia"]}

paises.extract("norte", "bolivia").then(nuevos => {
  console.log(nuevos)
}).catch(error => {
  console.log(error)
})

//Esto retorna en el .catch()
```
![error](https://cdn.discordapp.com/attachments/704375674172866570/706662711961845820/unknown.png)


## Ejemplo usando algunas funciones:
```js
const db = require('megadb');
let estadisticas = new db.crearDB('niveles');

let randomXP = Math.floor(Math.random() * 60) + 1;

if(!estadisticas.tiene('MegaStar')) {
  estadisticas.establecer('MegaStar', {xp: 0, nivel: 1});
}

estadisticas.obtener('MegaStar').then(datos => {
  if((randomXP + datos.xp) >= 50) {
    estadisticas.establecer('MegaStar', {xp: 0, nivel: datos.nivel + 1}).then(nuevos => {
      let nuevo_nivel = nuevos['MegaStar'].nivel
      console.log(`MegaStar subio al nivel ${nuevo_nivel}!`)
    }).catch(err => console.log(err))
  }
  else{
    estadisticas.sumar('MegaStar.xp', randomXP)
  }
}).catch(err => console.log(err))


/////////////////////////////////////////////////////


const db = require('megadb');
let escuela = new db.crearDB('alumnos');

escuela.establecer('MegaStar', {edad: 20, profesion: ['programador']});
escuela.establecer('MoDeR', {edad: 18, profesion: ['programador']});
escuela.establecer('RatSageM', {edad: 25, profesion: ['maestro']});


escuela.datos().then(alumnos => {
  for(var alumno in alumnos) {
    if(alumnos[alumno].profesion.includes('programador')) {
      escuela.push(`${alumno}.profesion`, 'javascript');
      continue;
    }
    escuela.eliminar(`${alumno}`)
  }
})


//resultado final:
{
  "MegaStar": {
    "edad": 20,
    "profesion": ["programador", "javascript"]
  },
  "MoDeR": {
    "edad": 18,
    "profesion": ["programador", "javascript"]
  }
}

/////////////////////////////////////////////////////

const db = require('megadb');
let mercado_db = new db.crearDB('mercado');

let nombres = ['manzana', 'melocoton', 'sandia', 'lechuga']

mercado_db.establecer('frutas', nombres); //esto retorna {frutas: ['manzana', 'melocoton', 'sandia', 'lechuga']}

mercado_db.obtener('frutas').then(f => {
  for(var x = 0; x < f.length; x++) {
    if(f[x] == 'lechuga') {
      mercado_db.extract('lechuga').then(nuevas_frutas => {
        //esto retorna ['manzana', 'melocoton', 'sandia']
        console.log(`La ${f[x]} no es una fruta, acabo de removerlo.`)      
      }).catch(error => {
        console.log(`Ocurrio un error: ${error.type}, mensaje: ${error.mensaje}`)
      })
      break;
    }
  }
}).catch(error => {
  console.log(error)
})



//resultado final:
{
  "frutas": ["manzana", "melocoton", "sandia"]
}

/////////////////////////////////////////////////////


const db = require('megadb');
let economia_db = new db.crearDB('economia')

let usuarios = {
  megastar: {monedas: 10, medallas: 15},
  moder: {monedas: 50, medallas: 20},
  ratsagem: {monedas: 25, medallas: 5}
}

economia_db.establecer('servidor.datos', usuarios)

economia_db.ordenar('servidor.datos', "monedas").then(nuevos => {
  let ranking = []
  for(var x = 0; x < nuevos.length; x++) {
    ranking.push(`rank #${parseInt(x+1)} | usuario: ${nuevos[x].clave} | monedas: ${nuevos[x].valor.monedas} | medallas: ${nuevos[x].valor.medallas}\n`)
  }
}).catch(error => console.log(error))


/*
resultado:

rank #1 | usuario: moder | monedas: 50 | medallas: 20
rank #2 | usuario: ratsagem | monedas: 25 | medallas: 5
rank #3 | usuario: megastar | monedas: 10 | medallas: 20

*/


/////////////////////////////////////////////////////


const db = require('megadb');
let login_db = new db.crearDB('login')

let registered_users = {
  "Mario": "password1",
  "MegaStar": "password2",
  "MoDeR": "password3",
  "RatSageM": "password4"
}


login_db.establecer('usuarios', registered_users)

/*
Estructura actual de la base de datos login.json:

{
  "usuarios": {
    "Mario": "password1",
    "MegaStar": "password2",
    "MoDeR": "password3",
    "RatSageM": "password4"
  }
}

*/

login_db.keys('usuarios').then(users => {
  console.log(`Nombres de los usuarios registrados: ${users.join(", ")}`)
}).catch(error => console.log(error))

//resultado: "Nombres de los usuarios registrados: Mario, MegaStar, MoDeR, RatSageM"
```
