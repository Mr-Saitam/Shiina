const { check_path_object } = require("../utils/utilidades.js"),
	  { establecer } = require("../methods/establecer.js"),
	  { obtener } = require("../methods/obtener.js"),
	  { tiene } = require("../methods/tiene.js"),
	  { eliminar } = require("../methods/eliminar.js"),
	  { purgeall } = require("../methods/purgeall.js"),
	  { sumar } = require("../methods/sumar.js"),
	  { restar } = require("../methods/restar.js"),
	  { push } = require("../methods/push.js"),
	  { extract } = require("../methods/extract.js"),	
	  { datos } = require("../methods/datos.js"),	
	  { ordenar } = require("../methods/ordenar.js"),
	  { random } = require("../methods/random.js"),	
	  { keys } = require("../methods/keys.js"),
	  { values } = require("../methods/values.js"),
	  { size } = require("../methods/size.js"),	    
	  { find } = require("../methods/find.js"),	 
	  { filter } = require("../methods/filter.js"),
	  { map } = require("../methods/map.js"),
	  { some } = require("../methods/some.js"),
		{ setIndex } = require("../methods/setIndex.js"),	  
		{ delIndex } = require("../methods/delIndex.js"),
		{ findKey } = require("../methods/findKey.js"),
		{ partition } = require("../methods/partition.js"),		
			errorDB = require("./errorDB.js");

let global_object = new Object();


class memoDB {

	constructor(database_name) {
		if(!database_name) throw new errorDB(`[ERROR](memoDB) Necesitas colocar el nombre de la base de datos`)
	  	if(typeof database_name != "string") throw new errorDB(`[ERROR](memoDB) El nombre de la base de datos ${database_name} debe ser un string`)
	  	database_name = database_name.trim()
	  	if(database_name.length <= 0) throw new errorDB(`[ERROR](memoDB) Necesitas colocar un nombre a la base de datos`)

	  	this.database_name = database_name
	  	this.object_id = database_name
	  	if(!global_object[this.object_id]) {
	  		global_object[this.object_id] = {}
		}
	}


	establecer(clave, valor, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'CLAVE INVALIDA', 'establecer', clave, valor)
		check_path_object(clave, split_object, 'establecer', valor)
		if(!valor && valor != 0) throw new errorDB(`El valor no fue especificado`, 'VALOR INVALIDO', 'establecer', clave, valor)
	  return establecer(clave, valor, split_object, global_object, this, false)
	}


	set(clave, valor, split_object) { //ALIAS DEL METODO ESTABLECER
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'set', clave, valor)
	  check_path_object(clave, split_object, 'set', valor)
	  if(!valor && valor != 0) throw new errorDB(`El valor no fue especificado`, 'VALOR INVALIDO', 'set', clave, valor)
	  return establecer(clave, valor, split_object, global_object, this, false)
	}


	obtener(clave, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'obtener', clave)
	  check_path_object(clave, split_object, 'obtener')
	  return obtener(clave, split_object, global_object, this)
	}


	get(clave, split_object) { //ALIAS DEL METODO OBTENER
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'get', clave)
	  check_path_object(clave, split_object, 'get')
	  return obtener(clave, split_object, global_object, this)
	}


	tiene(clave, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'tiene', clave)
	  check_path_object(clave, split_object, 'tiene')
	  return tiene(clave, split_object, global_object, this)
	}


	has(clave, split_object) { //ALIAS DEL METODO TIENE
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'has', clave)
	  check_path_object(clave, split_object, 'has')
	  return tiene(clave, split_object, global_object, this)
	}


	eliminar(clave, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'eliminar', clave)
	  check_path_object(clave, split_object, 'eliminar')
	  return eliminar(clave, split_object, global_object, this, false)
	}


	delete(clave, split_object) { //ALIAS DEL METODO ELIMINAR
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'delete', clave)
	  check_path_object(clave, split_object, 'delete')
	  return eliminar(clave, split_object, global_object, this, false)
	}


	purgeall() {
	  return purgeall(global_object, this, false)
	}


	sumar(clave, number, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'sumar', clave, number)
	  check_path_object(clave, split_object, 'sumar', number)
	  return sumar(clave, number, split_object, global_object, this, false)
	}


	add(clave, number, split_object) { //ALIAS DEL METODO SUMAR
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'add', clave, number)
	  check_path_object(clave, split_object, 'add', number)
	  return sumar(clave, number, split_object, global_object, this, false)
	}


	restar(clave, number, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'restar', clave, number)
	  check_path_object(clave, split_object, 'restar', number)
	  return restar(clave, number, split_object, global_object, this, false)
	}


	subtract(clave, number, split_object) { //ALIAS DEL METODO RESTAR
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'subtract', clave, number)
	  check_path_object(clave, split_object, 'subtract', number)
	  return restar(clave, number, split_object, global_object, this, false)
	}


	push(clave, valor, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'push', clave, valor)
	  check_path_object(clave, split_object, 'push', valor)	
	  return push(clave, valor, split_object, global_object, this, false)	
	}


	extract(clave, valor, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'extract', clave, valor)
	  check_path_object(clave, split_object, 'extract', valor)
	  return extract(clave, valor, split_object, global_object, this, false)
	}


	datos() {
	  return datos(global_object, this)
	}


	ordenar(clave, valor, split_object) {
	  if(!split_object) split_object = "."
		if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'ordenar', clave, valor)
	  return ordenar(clave, valor, split_object, global_object, this)
	}


	sort(clave, valor, split_object) { //ALIAS DEL METODO ORDENAR
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'sort', clave, valor)
	  return ordenar(clave, valor, split_object, global_object, this)
	}


	random(clave, cantidad, split_object) {
	  if(!split_object) split_object = "."
		if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'random', clave, cantidad)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'random', clave, cantidad)
	  if(!cantidad && cantidad != 0) throw new errorDB(`Necesitas colocar la cantidad(numero)`, 'NUMERO INVALIDO', 'random', clave, cantidad)
	  if(isNaN(cantidad)) throw new errorDB(`La cantidad debe ser un numero`, 'NUMERO INVALIDO', 'random', clave, cantidad)
	  cantidad = cantidad > 0 ?  parseInt(cantidad) : 0	  	
	  return random(clave, cantidad, split_object, global_object, this)
	}


	keys(clave = false, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'keys', clave)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'keys', clave)	  		  	
	  return keys(clave, split_object, global_object, this)
	}


	values(clave = false, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'values', clave)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'values', clave)
	  return values(clave, split_object, global_object, this)	  	
	}


	size() {
	  return size(global_object, this)
	}


	find(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'find', clave, callback)		
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'find', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB(`El segundo argumento debe ser un callback (funcion)`, 'CLAVE INVALIDA', 'find', clave, callback) 	  	
	  return find(clave, callback, split_object, global_object, this)	
	}


	filter(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'filter', clave, callback)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'filter', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB('El segundo argumento debe ser un callback (funcion)', 'CLAVE INVALIDA', 'filter', clave, callback)
	  return filter(clave, callback, split_object, global_object, this)	  	  		
	}


	map(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'map', clave, callback)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'map', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB('El segundo argumento debe ser un callback (funcion)', 'CLAVE INVALIDA', 'map', clave, callback)
	  return map(clave, callback, split_object, global_object, this)		
	}


	some(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'some', clave, callback)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'some', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB('El segundo argumento debe ser un callback (funcion)', 'CLAVE INVALIDA', 'some', clave, callback)
	  return some(clave, callback, split_object, global_object, this)		
	}

	
	setIndex(clave, index, valor, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'setIndex', clave, index)
	  check_path_object(clave, split_object, 'setIndex', index)	
	  return setIndex(clave, index, valor, split_object, global_object, this, false)	
	}


	delIndex(clave, index, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'delIndex', clave, index)
	  check_path_object(clave, split_object, 'delIndex', index)	
	  return delIndex(clave, index, split_object, global_object, this, false)	
	}
	

	findKey(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'findKey', clave, callback)	
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'findKey', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB('El segundo argumento debe ser un callback (funcion)', 'CLAVE INVALIDA', 'findKey', clave, callback)	   	
	  return findKey(clave, callback, split_object, global_object, this)	
	}


	partition(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'partition', clave, callback)			
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'partition', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB('El segundo argumento debe ser un callback (funcion)', 'CLAVE INVALIDA', 'partition', clave, callback)	
	  return partition(clave, callback, split_object, global_object, this)	
	}
}

module.exports = memoDB
