const { check_path_object, build_path, readJSON } = require("../utils/utilidades.js"),
	  { establecer } = require("../methods/establecer.js"),
	  { obtener } = require("../methods/obtener.js"),
	  { tiene } = require("../methods/tiene.js"),
	  { eliminar } = require("../methods/eliminar.js"),
	  { purgeall } = require("../methods/purgeall.js"),
	  { sumar } = require("../methods/sumar.js"),
	  { restar } = require("../methods/restar.js"),
	  { push } = require("../methods/push.js"),
	  { extract } = require("../methods/extract.js"),	
	  { datos } = require("../methods/datos.js"),	
	  { ordenar } = require("../methods/ordenar.js"),
	  { random } = require("../methods/random.js"),	
	  { convert_megadtbs } = require("../methods/convert_megadtbs.js"),
	  { keys } = require("../methods/keys.js"),
	  { values } = require("../methods/values.js"),
	  { size } = require("../methods/size.js"),	    
	  { find } = require("../methods/find.js"),	 
	  { filter } = require("../methods/filter.js"),
	  { map } = require("../methods/map.js"),
		{ some } = require("../methods/some.js"),	
		{ setIndex } = require("../methods/setIndex.js"),	  
		{ delIndex } = require("../methods/delIndex.js"),
		{ findKey } = require("../methods/findKey.js"),
		{ partition } = require("../methods/partition.js"), 	   	    	  	  	    	  
		errorDB = require("./errorDB.js");


let global_object = new Object();


class crearDB {

	constructor(database_name, sub_directory = false) {

		let settings = {nombre: "", carpeta: "mega_databases", sub: false, guardar_tiempo: false}
	
		if(typeof database_name == "object" && !(database_name instanceof Array)) settings = database_name
		else{
			settings.nombre = database_name
			settings.sub = sub_directory
		}

		let parse_data = build_path(settings)
		this.database_name = parse_data.nombre;
		this.path_file_name = parse_data.path_json;
		this.path_main_carpet = parse_data.path_carpet;
		this.object_id = parse_data.object_id;
		this.save_time = parse_data.save_time;

		(function(path_file_name, object_id) {
			if(!global_object[object_id]) {
					global_object[object_id] = readJSON(path_file_name)
			}
		}(this.path_file_name, this.object_id))
	}


	establecer(clave, valor, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'CLAVE INVALIDA', 'establecer', clave, valor)
		check_path_object(clave, split_object, 'establecer', valor) 
		if(!valor && valor != 0) throw new errorDB(`El valor no fue especificado`, 'VALOR INVALIDO', 'establecer', clave, valor)
	  return establecer(clave, valor, split_object, global_object, this, true)
	}


	set(clave, valor, split_object) { //ALIAS DEL METODO ESTABLECER
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'set', clave, valor)
	  check_path_object(clave, split_object, 'set', valor)
	  if(!valor && valor != 0) throw new errorDB(`El valor no fue especificado`, 'VALOR INVALIDO', 'set', clave, valor)
	  return establecer(clave, valor, split_object, global_object, this, true)
	}	


	obtener(clave, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'obtener', clave)
	  check_path_object(clave, split_object, 'obtener')
	  return obtener(clave, split_object, global_object, this)
	}


	get(clave, split_object) { //ALIAS DEL METODO OBTENER
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'get', clave)
	  check_path_object(clave, split_object, 'get')
	  return obtener(clave, split_object, global_object, this)
	}


	existeDB(database_name) {
	  if(!database_name) throw new errorDB(`El nombre de la base de datos no fue especificado`, 'NOMBRE INVALIDO', 'existeDB', database_name)
	  if(typeof database_name != "string") throw new errorDB(`El nombre de la base de datos debe ser un string`, 'NOMBRE INVALIDO', 'existeDB', database_name)
	  if(!fs.existsSync(path.join(this.path_main_carpet,`${database_name}.json`))) return false
	  return true
	}


	tiene(clave, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'tiene', clave)
	  check_path_object(clave, split_object, 'tiene')
	  return tiene(clave, split_object, global_object, this)
	}


	has(clave, split_object) { //ALIAS DEL METODO TIENE
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'has', clave)
	  check_path_object(clave, split_object, 'has')
	  return tiene(clave, split_object, global_object, this)
	}


	eliminar(clave, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'eliminar', clave)
	  check_path_object(clave, split_object, 'eliminar')
	  return eliminar(clave, split_object, global_object, this, true)
	}


	delete(clave, split_object) { //ALIAS DEL METODO ELIMINAR
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'delete', clave)
	  check_path_object(clave, split_object, 'delete')
	  return eliminar(clave, split_object, global_object, this, true)
	}


	purgeall() {
	  return purgeall(global_object, this, true)
	}


	sumar(clave, number, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'sumar', clave, number)
	  check_path_object(clave, split_object, 'sumar', number)
	  return sumar(clave, number, split_object, global_object, this, true)
	}


	add(clave, number, split_object) { //ALIAS DEL METODO SUMAR
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'add', clave, number)
	  check_path_object(clave, split_object, 'add', number)
	  return sumar(clave, number, split_object, global_object, this, true)
	}


	restar(clave, number, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'restar', clave, number)
	  check_path_object(clave, split_object, 'restar', number)
	  return restar(clave, number, split_object, global_object, this, true)
	}


	subtract(clave, number, split_object) {  //ALIAS DEL METODO RESTAR
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'subtract', clave, number)
	  check_path_object(clave, split_object, 'subtract', number)
	  return restar(clave, number, split_object, global_object, this, true)
	}


	push(clave, valor, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'push', clave, valor)
	  check_path_object(clave, split_object, 'push', valor)	
	  return push(clave, valor, split_object, global_object, this, true)	
	}


	extract(clave, valor, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'extract', clave, valor)
	  check_path_object(clave, split_object, 'extract', valor)
	  return extract(clave, valor, split_object, global_object, this, true)
	}


	datos() {
	  return datos(global_object, this)
	}


	ordenar(clave, valor, split_object) {
	  if(!split_object) split_object = "."
		if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'ordenar', clave, valor)
	  return ordenar(clave, valor, split_object, global_object, this)
	}


	sort(clave, valor, split_object) { //ALIAS DEL METODO ORDENAR
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'sort', clave, valor)
	  return ordenar(clave, valor, split_object, global_object, this)
	}


	random(clave, cantidad, split_object) {
	  if(!split_object) split_object = "."
		if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'random', clave, cantidad)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'random', clave, cantidad)
	  if(!cantidad && cantidad != 0) throw new errorDB(`Necesitas colocar la cantidad(numero)`, 'NUMERO INVALIDO', 'random', clave, cantidad)
	  if(isNaN(cantidad)) throw new errorDB(`La cantidad debe ser un numero`, 'NUMERO INVALIDO', 'random', clave, cantidad)
	  cantidad = cantidad > 0 ?  parseInt(cantidad) : 0	  	
	  return random(clave, cantidad, split_object, global_object, this)
	}


	convert_megadtbs() {
	  return convert_megadtbs(this)
	}


	keys(clave = false, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'keys', clave)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'keys', clave)	  	
	  return keys(clave, split_object, global_object, this)
	}


	values(clave = false, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'values', clave)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'values', clave)
	  return values(clave, split_object, global_object, this)	  	
	}


	size() {
	  return size(global_object, this)
	}


	find(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'find', clave, callback)		
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'find', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB(`El segundo argumento debe ser un callback (funcion)`, 'CLAVE INVALIDA', 'find', clave, callback) 	
	  return find(clave, callback, split_object, global_object, this)	
	}


	filter(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'filter', clave, callback)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'filter', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB('El segundo argumento debe ser un callback (funcion)', 'CLAVE INVALIDA', 'filter', clave, callback)
	  return filter(clave, callback, split_object, global_object, this)	  	  		
	}


	map(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'map', clave, callback)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'map', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB('El segundo argumento debe ser un callback (funcion)', 'CLAVE INVALIDA', 'map', clave, callback)
	  return map(clave, callback, split_object, global_object, this)		
	}


	some(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'some', clave, callback)
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'some', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB('El segundo argumento debe ser un callback (funcion)', 'CLAVE INVALIDA', 'some', clave, callback)
	  return some(clave, callback, split_object, global_object, this)		
	}


	setIndex(clave, index, valor, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'setIndex', clave, index)
	  check_path_object(clave, split_object, 'setIndex', index)	
	  return setIndex(clave, index, valor, split_object, global_object, this, true)
	}


	delIndex(clave, index, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'delIndex', clave, index)
	  check_path_object(clave, split_object, 'delIndex', index)	
	  return delIndex(clave, index, split_object, global_object, this, true)	
	}


	findKey(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'findKey', clave, callback)	
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'findKey', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB('El segundo argumento debe ser un callback (funcion)', 'CLAVE INVALIDA', 'findKey', clave, callback)	  	
	  return findKey(clave, callback, split_object, global_object, this)	
	}


	partition(clave, callback, split_object) {
	  if(!split_object) split_object = "."
	  if(typeof split_object != "string") throw new errorDB(`El signo que se usara para la clave debe ser un string`, 'SIGNO INVALIDO', 'partition', clave, callback)			
	  if(clave !== false && typeof clave != "string") throw new errorDB(`La clave debe ser un string o false`, 'CLAVE INVALIDA', 'partition', clave, callback)
	  if(!callback || typeof callback != "function") throw new errorDB('El segundo argumento debe ser un callback (funcion)', 'CLAVE INVALIDA', 'partition', clave, callback)
	  return partition(clave, callback, split_object, global_object, this)	
	}
}

module.exports = crearDB
