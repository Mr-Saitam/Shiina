const { check_path_object } = require("../utils/utilidades.js"),
				errorDB = require("../class/errorDB.js");

module.exports = {
	ordenar: function(clave, valor, split_object, global_object, self) {

	  if(!clave && clave != false) throw new errorDB("El nombre de la clave no fue especificado", 'CLAVE INVALIDA', 'ordenar', clave, valor)
	  if(clave != false && typeof clave != "string") throw new errorDB("Formato invalido, la clave debe de ser un string o false en caso de que la clave no sea un objeto con propiedades", 'CLAVE INVALIDA', 'ordenar', clave, valor)
	  if(!valor && valor != false && valor != 0) throw new errorDB("El valor no fue especificado", 'VALOR INVALIDO', 'ordenar', clave, valor)

	  let final_array = []

	  if(clave == false) { //si la clave es false
	    if(valor == false) { //si el valor es false
	      for(var key in global_object[self.object_id]) {
	        if(typeof global_object[self.object_id][key] != "number") return Promise.reject(new errorDB(`El valor de la propiedad ${key} no es un numero, base de datos: ${self.database_name}`, 'NUMERO NO EXISTENTE', 'ordenar', clave, valor))
	        final_array.push({clave: key, valor: global_object[self.object_id][key]})
	      }
	      return Promise.resolve(final_array.sort((a,b) => b.valor - a.valor))
	    }
	    //si la clave es false y el valor es un string (path object)
	    if(typeof valor != "string") throw new errorDB("Formato invalido, el valor debe ser un string o false en caso de que el valor no sea un objeto con propiedades", 'VALOR INVALIDO', 'ordenar', clave, valor)
	    if(valor.includes(`${split_object}${split_object}`)) throw new errorDB(`El nombre del valor no debe de contener el signo ${split_object} seguido de otro`, 'VALOR INVALIDO', 'ordenar', clave, valor)
	    if(valor.startsWith(split_object) || valor.endsWith(split_object)) throw new errorDB(`El nombre del valor no debe empezar ni terminar con un ${split_object}`, 'VALOR INVALIDO', 'ordenar', clave, valor)

	    let [...args_value] = valor.split(split_object)

			for(var key in global_object[self.object_id]) {
				var object_data = global_object[self.object_id][key]
				for(var key_value of args_value) {
					if(!object_data.hasOwnProperty(key_value)) return Promise.reject(new errorDB(`No se encontro la propiedad ${key_value}, base de datos: ${self.database_name}`, 'PROPIEDAD NO EXISTENTE', 'ordenar', clave, valor))
					if(key_value == args_value[args_value.length-1]) {
						if(typeof object_data[key_value] != 'number') return Promise.reject(new errorDB(`El valor de la propiedad ${key_value} no es un numero, base de datos: ${self.database_name}`, 'NUMERO NO EXISTENTE', 'ordenar', clave, valor))
						final_array.push({clave: key, valor: object_data})
					}
					else {
						object_data = object_data[key_value]
					}
				}
			}
			return Promise.resolve(final_array.sort((a,b) => b.valor[args_value[args_value.length-1]] - a.valor[args_value[args_value.length-1]]))
		}

		check_path_object(clave, split_object, 'ordenar', valor)
	  if(valor == false) { //si la clave es un string (path object) y el valor es false
	    let [...args] = clave.split(split_object)

	    var object_data = global_object[self.object_id]

			for(var key of args) {
				if(!object_data.hasOwnProperty(key)) return Promise.reject(new errorDB(`No se encontro la propiedad ${key}, base de datos: ${self.database_name}`, 'PROPIEDAD NO EXISTENTE', 'ordenar', clave, valor))
				if(key == args[args.length-1]) {
					for(var key2 in object_data[key]) {
						if(typeof object_data[key][key2] != 'number') return Promise.reject(new errorDB(`El valor de la propiedad ${key2} no es un numero, base de datos: ${self.database_name}`, 'NUMERO NO EXISTENTE', 'ordenar', clave, valor))
						final_array.push({clave: key2, valor: object_data[key][key2]})
					}
				}
				else {
					object_data = object_data[key]
				}
			}
			return Promise.resolve(final_array.sort((a,b) => b.valor - a.valor))
	  }
	  //Si la clave y valor son string (path object)
	  if(typeof valor != "string") throw new errorDB("Formato invalido, el valor debe ser un string o false en caso de que el valor no sea un objeto con propiedades", 'VALOR INVALIDO', 'ordenar', clave, valor)
		if(valor.includes(`${split_object}${split_object}`)) throw new errorDB(`El nombre del valor no debe de contener el signo ${split_object} seguido de otro`, 'VALOR INVALIDO', 'ordenar', clave, valor)
		if(valor.startsWith(split_object) || valor.endsWith(split_object)) throw new errorDB(`El nombre del valor no debe empezar ni terminar con un ${split_object}`, 'VALOR INVALIDO', 'ordenar', clave, valor)

	  let [...args] = clave.split(split_object)
	  let [...args_value] = valor.split(split_object)

		var object_data = global_object[self.object_id]
		
		for(var key of args) {
			if(!object_data.hasOwnProperty(key)) return Promise.reject(new errorDB(`No se encontro la propiedad ${key}, base de datos: ${self.database_name}`, 'PROPIEDAD NO EXISTENTE', 'ordenar', clave, valor))
			if(key == args[args.length-1]) {
				object_data = object_data[key]
				for(var key2 in object_data) {
					var value_object = object_data[key2]
					for(var key_value of args_value) {
						if(!value_object.hasOwnProperty(key_value)) return Promise.reject(new errorDB(`No se encontro la propiedad ${key_value}, base de datos: ${self.database_name}`, 'PROPIEDAD NO EXISTENTE', 'ordenar', clave, valor))
						if(key_value == args_value[args_value.length-1]) {
							if(typeof value_object[key_value] != 'number') return Promise.reject(new errorDB(`El valor de la propiedad ${key_value} no es un numero, base de datos: ${self.database_name}`, 'NUMERO NO EXISTENTE', 'ordenar', clave, valor))
							final_array.push({clave: key2, valor: value_object})
						}
						else {
							value_object = value_object[key_value]
						}
					}
				}
			}
			else {
				object_data = object_data[key]
			}
		}
		return Promise.resolve(final_array.sort((a,b) => b.valor[args_value[args_value.length-1]] - a.valor[args_value[args_value.length-1]]))
	}
}